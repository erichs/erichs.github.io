<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Terminal Curiosity]]></title>
  <link href="http://erichs.github.io/feed" rel="self"/>
  <link href="http://erichs.github.io/"/>
  <updated>2014-08-06T10:31:17-04:00</updated>
  <id>http://erichs.github.io/</id>
  <author>
    <name><![CDATA[Erich Smith]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose with Confidence]]></title>
    <link href="http://erichs.github.io/blog/2014/08/06/compose-with-confidence/"/>
    <updated>2014-08-06T10:30:02-04:00</updated>
    <id>http://erichs.github.io/blog/2014/08/06/compose-with-confidence</id>
    <content type="html"><![CDATA[<p><a href="http://erichs.github.io/blog/2014/07/08/servant-of-two-masters/" title="Servant of Two Masters">Last time</a>, I noted that the experience of composing shell functions at the command prompt is awkward.</p>

<h2>REPLs ❤ Pipes</h2>

<p>The shell command prompt is great for quick <a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> feedback: run a command, watch
the output, tweak the command, and repeat until you have the output you desire.
This is a great way to build up complex command sequences. Feedback is
immediate, and the ability to recall and directly edit recent command history
encourages experimentation.</p>

<p>The prompt is no replacement for a full text editor, however, and there are times that you&rsquo;ll start a command at the prompt and <a href="http://nuclearsquid.com/writings/edit-long-commands/">wish you had done so in an editor</a>.</p>

<p>While available for short-term recall in terminal history, command sequences entered at the prompt have a short shelf-life. Shell functions defined (albeit painfully) at the prompt, for example, do not persist across shell invocations.</p>

<p>Composing a complex logic construct or shell function at the prompt is, at best, ephemeral and awkward.</p>

<h2>Scripts ❤ Functions</h2>

<p>Script <em>files</em> are the natural habitat for functions and larger programmatic constructs: after all, you have a full 2D editor environment in which to draft, save and revise your code. What might be a struggle and a chore to compose at the command prompt becomes easy inside a text editor.</p>

<p>Persisting to the filesystem means that you can bring all the tools for dealing
with files to bear on your script, including version control&mdash;critical to
maintaining code of any real complexity.</p>

<p>Script files have downsides, of course. Chief among them that you lose all the feedback from the command prompt&mdash;if you are creating a complex command sequence, you&rsquo;re flying blind inside the editor. Also, you&rsquo;ve just inherited all the file-related baggage required to get your script to actually run: shebang lines, executable bits, and PATH considerations.</p>

<p>Composing a complex logic construct or shell function in a script file feels natural, but loses the immediacy of the prompt and can sometimes feel too heavyweight: both factors which discourage the proliferation of lots of small shell functions, which as we&rsquo;ve seen can vastly improve the readability and maintainability of our command sequences.</p>

<h2>Best of both worlds?</h2>

<p>I care about readability in my shell code. If you&rsquo;re reading this, perhaps you do too. I wanted the best of both worlds, prompt <strong><em>and</em></strong> editor, so I wrote <a href="https://github.com/erichs/composure">composure, a set of opinionated shell functions that help you write shell functions</a>.</p>

<p>In a future post, I&rsquo;ll highlight a few of the features and benefits of writing shell functions with composure, and a few unexpected use cases I&rsquo;ve found.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Servant of Two Masters]]></title>
    <link href="http://erichs.github.io/blog/2014/07/08/servant-of-two-masters/"/>
    <updated>2014-07-08T14:08:36-04:00</updated>
    <id>http://erichs.github.io/blog/2014/07/08/servant-of-two-masters</id>
    <content type="html"><![CDATA[<p><a href="http://erichs.github.io/blog/2014/06/30/broken-windows-and-broken-code/" title="Broken Windows and Broken Code">Last time</a>, I brought up the subject of fixing shell commands as you go along, and suggested that the practice of doing so could be good for your programmatic health. Today I&rsquo;d like to highlight an underused Unix command that does this well, and talk through the broader implications of its use.</p>

<!-- more -->


<h2>The <code>fc</code> utility</h2>

<p>First introduced via the Korn Shell, and a <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/fc.html">standard Unix utility</a> since at least the mid-90&rsquo;s, <code>fc</code> is short for &ldquo;fix command&rdquo;. Its purpose is to open up a previous command in the editor of your choice, and re-run the revised command once you are finished editing it.</p>

<p>With no arguments, <code>fc</code> will open the most previous command in the editor for editing and re-evaluation. In pure shell terms, it is roughly equivalent to:</p>

<figure class='code'><figcaption><span>I hope you&#8217;ll agree, &#8216;fc&#8217; is easier to type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> !! &gt; /tmp/cmd <span class="o">&amp;&amp;</span> <span class="nv">$EDITOR</span> /tmp/cmd <span class="o">&amp;&amp;</span> <span class="nb">eval</span> <span class="k">$(</span>cat /tmp/cmd<span class="k">)</span><span class="p">;</span> rm /tmp/cmd
</span></code></pre></td></tr></table></div></figure>


<p>Most implementations of <code>fc</code> will use an editor specified in the <code>FCEDIT</code> environment variable, followed by <code>EDITOR</code>, then <code>vi</code>, and finally <code>ed</code>. You could of course launch an external editor like Sublime Text or Eclipse, but I find that keeping the editor inside the terminal feels most natural for this purpose.</p>

<p>I want to talk now about the experience of using a command like this. If you&rsquo;ve not used this utility before, go ahead and try it out a few times. Yes, right now. Seriously, I&rsquo;ll wait.</p>

<hr />


<center><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/9hmDZz5pDOQ" allowfullscreen></iframe></div></center>


<hr />


<h2>Context Switching</h2>

<p>So, kinda cool, but a little jarring, right? There you were happily plunking commands down at a prompt, and all of a sudden you&rsquo;re in your familiar editor, but perhaps in a slightly new context. Now you are editing your last command, say <code>ls -l</code>, as if it were a script:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'>
</span><span class='line'>ls -l
</span></code></pre></td></tr></table></div></figure>


<p>Furthermore, the act of saving and quitting ran the script, back at your terminal.</p>

<h2>Two Environments, Two Adaptations</h2>

<p>I think the feeling of slight disorientation that occurs when using <code>fc</code> for the first time stems from inherent tension between the two modes of operation, or execution environments of the shell interpreter: the shell is at once the familiar REPL prompt we use all the time, and the shell is also the interpreter of script files.</p>

<h3>The Prompt</h3>

<p>We naturally adapt our shell behaviors, as users, to these different execution environments: the interactive, REPL-nature of the prompt means that we can run a quick command, and immediately see the output displayed to the terminal. Based on that output, we might decide to try a different command altogether, consult a man page, or perhaps just hit the up arrow and make a quick revision to our command.</p>

<p>In particular, using the shell prompt to build up complex command pipelines is invaluable: you get to see the output of each filter command:</p>

<script type="text/javascript" src="https://asciinema.org/a/10680.js" id="asciicast-10680" async data-speed="2"></script>


<p>At the prompt, this feels natural. You try a command, examine the output or result, add an appropriate filter command or commands until you have massaged the output into a desired format. You have the benefit of <strong>understandability</strong> as a <strong>writer</strong> of the command because the output of all the intermediate commands are available to you <strong>while</strong> you are writing.</p>

<h3>The Script</h3>

<p>Contrast that experience with encountering something like this in a script:</p>

<figure class='code'><figcaption><span>Readability matters</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/usr/bin/env bash</span>
</span><span class='line'> netstat -p tcp <span class="p">|</span> grep -i established <span class="p">|</span> awk <span class="s1">&#39;{print $5}&#39;</span> <span class="p">|</span> awk -F<span class="s1">&#39;.&#39;</span> <span class="s1">&#39;{ $NF=&quot;&quot; } 1&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/ /./g&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/\.$//&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq
</span></code></pre></td></tr></table></div></figure>


<p>The above is simply unintelligible. Even if you are a regex master and know the syntax for each of the above commands, you do not have the benefit of having written that command to begin with. The intent of all those pipeline filters is not communicated to the reader, and unless you actually played with that command, one step at a time, at the prompt, it is unlikely you would ever know what that command does.</p>

<p><strong>Pipes, as a design feature, are central to the <a href="http://en.wikipedia.org/wiki/Unix_philosophy">Unix way</a></strong>. They are Unix&rsquo;s killer app. Unfortunately, they <strong>mask the intent</strong> of a command sequence. They are extremely convenient to use at a prompt, but end up being <em>write-only</em>.</p>

<p>The maintainer of a script with the above command sequence in it would be well-advised to break that command into sections, or at least encapsulate the pipeline in a descriptive function, like:</p>

<figure class='code'><figcaption><span>Names give the reader a clue</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/usr/bin/env bash</span>
</span><span class='line'>
</span><span class='line'><span class="k">function </span>unique_remote_connected_hosts <span class="o">{</span>
</span><span class='line'>  netstat -p tcp <span class="p">|</span> grep -i established <span class="p">|</span> awk <span class="s1">&#39;{print $5}&#39;</span> <span class="p">|</span> awk -F<span class="s1">&#39;.&#39;</span> <span class="s1">&#39;{ $NF=&quot;&quot; } 1&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/ /./g&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/\.$//&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>unique_remote_connected_hosts
</span></code></pre></td></tr></table></div></figure>


<p>or perhaps:</p>

<figure class='code'><figcaption><span>Composition helps</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/usr/bin/env bash</span>
</span><span class='line'>
</span><span class='line'><span class="k">function </span>unique_remote_connected_hosts <span class="o">{</span>
</span><span class='line'>  remote_connections <span class="p">|</span> strip_port_number <span class="p">|</span> sort <span class="p">|</span> uniq
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">function </span>remote_connections <span class="o">{</span>
</span><span class='line'>  netstat -p tcp <span class="p">|</span> grep -i established <span class="p">|</span> awk <span class="s1">&#39;{print $5}&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">function </span>strip_port_number <span class="o">{</span>
</span><span class='line'>  awk -F<span class="s1">&#39;.&#39;</span> <span class="s1">&#39;{ $NF=&quot;&quot; } 1&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/ /./g&#39;</span> <span class="p">|</span> sed <span class="s1">&#39;s/\.$//&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>unique_remote_connected_hosts
</span></code></pre></td></tr></table></div></figure>


<p>This functional composition is easy to do in a text editor, the natural habitat of a script. It is awkward and difficult to do at the prompt, which is too bad.</p>

<p>More on resolving this fundamental tension, next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Broken Windows and Broken Code]]></title>
    <link href="http://erichs.github.io/blog/2014/06/30/broken-windows-and-broken-code/"/>
    <updated>2014-06-30T13:31:31-04:00</updated>
    <id>http://erichs.github.io/blog/2014/06/30/broken-windows-and-broken-code</id>
    <content type="html"><![CDATA[<p>In the <a href="http://erichs.github.io/blog/2014/06/27/curious-case-of-the-disappearing-cats/" title="Curious Case of the Disappearing Cats">previous post</a> I talked about the Useless Use of Cat, and suggested that this is a habit worth breaking.</p>

<p>Really, though&mdash;isn&rsquo;t There More Than One Way To Skin A Cat? If <code>cat</code> with a single file argument gets the job done, who besides <a href="http://www.smallo.ruhr.de/award.html">Randal Schwartz</a> cares?</p>

<p>I care, and I think you should too.</p>

<!-- more -->


<p>The <a href="http://en.wikipedia.org/wiki/Broken_windows_theory">Broken Windows Theory</a> suggests that by continuing to use a broken mental model of the <code>cat</code> utility, when you know of a better way, you may be subtly devaluing your surrounding code, and inviting future abuse. Left unchecked, this kind of thinking forms habits that tend to spider outward and, weed-like, slowly choke the life out of a project.</p>

<p>Saying &ldquo;Who cares?&rdquo; to fixable issues within your sphere of control and influence is, in effect, choosing laziness.</p>

<p>Laziness can be a <a href="http://threevirtues.com/">virtue</a>, but it has a dark side, and must be employed intelligently.</p>

<p>Laziness in the form of putting off much-needed refactoring leads to design spaghetti and unmaintainable code: Fail. <i class="fa fa-thumbs-down"></i> This is self-defeating behavior that saps your morale, your momentum needed to accomplish the next task, and your motivation to continue learning and growing. This path ultimately leads to the place programmers go to die: maintaining some ancient application that everyone lives in fear of changing, hoping they are too valuable to be fired. Don&rsquo;t be a <a href="http://en.wikipedia.org/wiki/Wally_(Dilbert)">Wally</a>.</p>

<p>Laziness employed in service of, say, Test-Driven Design leads to deferring design decisions and coding the simplest thing that could possibly work: Win. <i class="fa fa-thumbs-up"></i> This is wise coding that stems from an experiential belief that you will know more about your problem domain tomorrow than you do today. Implicit in this belief is an internal drive to be constantly learning, and a promise, to yourself at least, that tomorrow you will clean up any messes you unintentionally make today.</p>

<p>Don&rsquo;t devalue your own worth, sense of accomplishment, and ability to grow. Fix that broken window today.</p>

<p>More on fixing your shell commands as you go, next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curious Case of the Disappearing Cats]]></title>
    <link href="http://erichs.github.io/blog/2014/06/27/curious-case-of-the-disappearing-cats/"/>
    <updated>2014-06-27T11:02:58-04:00</updated>
    <id>http://erichs.github.io/blog/2014/06/27/curious-case-of-the-disappearing-cats</id>
    <content type="html"><![CDATA[<p>As any Unix veteran will tell you, the <code>cat</code> utility is much abused. Here&rsquo;s the common scenario:</p>

<figure class='code'><figcaption><span>Useless Use of Cat</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat myfile <span class="p">|</span> grep mypattern
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this kind of abuse isn&rsquo;t limited to the &ldquo;pipe to grep&rdquo; variety. Here&rsquo;s the general form:</p>

<figure class='code'><figcaption><span>It&#8217;s not good for my&#8230; idiom.</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat &lt;file&gt; <span class="p">|</span> &lt;<span class="nb">command</span>&gt; arg1 arg2 argN
</span></code></pre></td></tr></table></div></figure>


<p>Indeed, flaming other Unix users for the <a href="http://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat">Useless Use of Cat</a> has long been the &lsquo;national sport&rsquo; of the Unix tribe, since Usenet days.</p>

<!-- more -->


<h1>What&rsquo;s wrong with this pattern?</h1>

<p>One thing, certainly. Two things, probably.</p>

<h2>1. <code>cat</code> is meant to concatenate two or more files together</h2>

<p>If you are using <code>cat</code> with only one filename argument, then by definition you aren&rsquo;t concatenating anything.</p>

<p>So, here&rsquo;s the proper use of <code>cat</code>:</p>

<figure class='code'><figcaption><span>meow</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat blacklion.txt greenlion.txt redlion.txt bluelion.txt yellowlion.txt &gt; VOLTRON.txt
</span></code></pre></td></tr></table></div></figure>


<h2>2. many commands accept STDIN, but prefer a filename argument</h2>

<p>This falls into a related anti-pattern of &ldquo;Useless Use of Pipe&rdquo;. Instead of:</p>

<figure class='code'><figcaption><span>Useless Use of Pipe</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat internet_memes.txt <span class="p">|</span> grep -i <span class="s2">&quot;chuck norris&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Consider:</p>

<figure class='code'><figcaption><span>He doesn&#8217;t sleep, he waits&#8230;</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep -i <span class="s2">&quot;chuck norris&quot;</span> internet_memes.txt
</span></code></pre></td></tr></table></div></figure>


<h1>Why is this such a common anti-pattern?</h1>

<p>I still find myself occasionally falling into this pattern, despite two decades&#8217; worth of keyboard time on Unix variants. I think this habit likely persists for two reasons:</p>

<h2>1. The habit is learned early</h2>

<p>Early bad habits are often hard to break. One of the first things a CLI user wants to do is to read a file, and until the use of pager commands becomes second nature, this will likely lead to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat somefile
</span></code></pre></td></tr></table></div></figure>


<p>For small ASCII files, this may even be an appropriate use of <code>cat</code>. Usually though, this early habit leads to a second, more subtle, and persistent mental model.</p>

<h2>2. <code>cat</code> is a conceptual pipeline source</h2>

<p>When building up a complex filter, often <code>cat</code> starts things off:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat myfile <span class="p">|</span> grep pattern <span class="p">|</span> tr <span class="s1">&#39;A-Z&#39;</span> <span class="s1">&#39;a-z&#39;</span> &gt; outfile
</span></code></pre></td></tr></table></div></figure>


<p>The thought process behind this command is: start with some text, then filter it thus, and filter it so, then write it to an output file. Simple. In some cases, I even give myself a pass on this if it makes my intention clearer. Usually, though, I try to fix the habit.</p>

<h1>The Fix?</h1>

<p>Refactoring. No, really. More on this next time.</p>

<h1>Bonus: Useless use of <code>wc</code></h1>

<p>Often I will do the following to get a matching pattern count:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat file1 file2 <span class="p">|</span> grep pattern <span class="p">|</span> wc -l
</span></code></pre></td></tr></table></div></figure>


<p>So, first let&rsquo;s clean up the UUoP:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep pattern file1 file2 <span class="p">|</span> wc -l
</span></code></pre></td></tr></table></div></figure>


<p>Turns out, <code>grep</code> has a <code>-c</code> flag, which displays the count of matched lines, so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep -c pattern file1 file2
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://erichs.github.io/blog/2014/06/25/hello-world/"/>
    <updated>2014-06-25T22:30:30-04:00</updated>
    <id>http://erichs.github.io/blog/2014/06/25/hello-world</id>
    <content type="html"><![CDATA[

<div class="highlight"><pre><code class="ruby"><span class="n">cats</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">cat</span><span class="o">|</span>
  <span class="n">cat</span><span class="o">.</span><span class="n">kill</span> <span class="k">if</span> <span class="n">cat</span><span class="o">.</span><span class="n">curious?</span>
<span class="k">end</span></code></pre></div>



]]></content>
  </entry>
  
</feed>
